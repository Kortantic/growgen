#!/usr/bin/env python
"""
A genetic algorithm that optimizes the placement of feeder cells in a PhysiCell simulation. The simulation
is a 2-dimensional cross-section intended to represent lab-grown muscle cells. Feeders would be the cross-section
of artificial blood vessels used to disperse oxygen and nutrients in a stationary growing environment. User parameters
are inserted directly into the source in the marked section, before the call to geneticAlgorithm(...)
"""

from numpy.random import randint
from numpy.random import rand
import xml.etree.ElementTree as ET
import subprocess
from pathlib import Path
from loader.pyMCDS import pyMCDS
import sys
from contextlib import redirect_stdout
from time import time, strftime, gmtime
from shutil import copyfile
import os
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
# This setting of os.environ is necessary to avoid conflicts with current dlls in the system path
vipshome = 'C:\\Users\\korle\\Documents\\0USU\\Spring 2021\\CS5890 AI and Clean Energy\\vips-dev-w64-all-8.10.6\\vips-dev-8.10\\bin'
os.environ['PATH'] = vipshome + ';' + os.environ['PATH']
import pyvips as pv

# Expects a pre-compiled physicell implementation, with a project ready to run

# TODO: Update to the living cell (type 14) fitness function
# TODO: Possible bug in scaling bounds (not a problem if input stays at [-256,256] like it is for this project)
# TODO: (stretch) Make it so tumor radius can be modified here
# TODO: (stretch) Add a cost associated with adding another feeder cell, and optimize the number of feeders as well


def readSettings(filepath):
    """
    Reads the PhysiCell settings file and parses the variables from the microenvironment into a dictionary.
    :param filepath: path to the xml file
    :return: a dictionary in the form { name: {units:*,ID:*,initial_condition:*,dirichlet_boundary_condition:*}}
    """
    env_variables = {}
    tree = ET.parse(filepath)
    root = tree.getroot()
    for var in root[5].findall('variable'):
        name = var.get('name')
        units = var.get('units')
        ID = var.get('ID')
        initial_condition = float(var.find('initial_condition').text)
        dirichlet_boundary_condition = float(var.find('Dirichlet_boundary_condition').text)
        env_variables.update({name: {"units": units,
                                     "ID": ID,
                                     "initial_condition": initial_condition,
                                     "dirichlet_boundary_condition": dirichlet_boundary_condition}})

    return env_variables

def saveXMLsettings(filepath, settings):
    """
    Opens PhysiCell_settings.xml, compares changes to the settings dictionary, updates values that have changed,
    and overwrites the previous settings.
    :param filepath: path to PhysiCell_settings.xml
    :param settings: settings dict generated by a previous call to readSettings()
    """
    tree = ET.parse(filepath)
    root = tree.getroot()
    for var in root[5].findall('variable'):
        if (name := var.get('name')) in settings:
            var.find('initial_condition').text = str(settings[name]['initial_condition'])
            var.find('Dirichlet_boundary_condition').text = str(settings[name]['dirichlet_boundary_condition'])
    tree.write(f'{filepath}')


def physicellOutputCapture(fromPath, toPath, start=0):
    """
    Saves physicell output sequentially
    :param fromPath: path to physicell output folder
    :param toPath: path to folder where files will be saved
    """
    # Check if folders exist, if they don't, create them
    bestInitials = toPath / 'bestInitials'
    bestFinals = toPath / 'bestFinals'
    if not bestInitials.exists():
        bestInitials.mkdir(parents=True)
    if not bestFinals.exists():
        bestFinals.mkdir(parents=True)

    index = start

    def output():
        """ Copies output from physicell to the target folder in sub-folders 'bestInitials' and 'bestFinals' """
        fileNumber = str(index).zfill(8)

        initialFile = fromPath / 'initial.svg'
        initialSequential = f'initial{fileNumber}.svg'
        initialTarget = toPath / 'bestInitials' / initialSequential
        copyfile(initialFile, initialTarget)

        finalFile = fromPath / 'final.svg'
        finalSequential = f'final{fileNumber}.svg'
        finalTarget = toPath / 'bestFinals' / finalSequential
        copyfile(finalFile, finalTarget)
        return fileNumber

    # generator makes it so the file numbers can continually increment without logic in main
    while True:
        yield output()
        index += 1


def animate(outputDirectory, width, height, fromFiletype, toFiletype, framerate):
    """
    Animates the svg output illustrating the progression of the algorithm
    :param outputDirectory: the directory that the genetic algorithm outputs to
    :param width: width of the animated image
    :param height: height of the animated image
    :param fromFiletype: the type of image to look for in order to animate
    :param toFiletype: the file extension, without a period, valid entries are: gif, webp
    :param framerate: miliseconds, how long to hold each frame
    """
    def animateFolder(directory):
        """
        Uses pyvips library to create an animated gif out of svg files in a given directory
        :param directory: directory to create animation from svgs in
        """
        initialOutputDirectory = outputDirectory / directory
        imgFiles = list(initialOutputDirectory.glob(f'*.{fromFiletype}'))
        if imgFiles:
            convertedImages = [pv.Image.thumbnail(str(i), width, height=height) for i in imgFiles]

            frameDelay = [framerate for frame in convertedImages]

            new_image = pv.Image.arrayjoin(convertedImages, across=1)
            new_image.set_type(pv.GValue.gdouble_type, 'page-height', height)
            new_image.set_type(pv.GValue.array_int_type, 'delay', frameDelay)

            filename = f"{Path(imgFiles[0]).stem[:-8]}.{toFiletype}"
            new_image.write_to_file(str(initialOutputDirectory / filename))

    animateFolder('bestInitials')
    animateFolder('bestFinals')


def fitnessEvaluation(physicellPath):
    """
    Runs PhysiCell silently. PhysiCell will take whatever settings are in its XML and run the simulation. The python
    loader module is then used to asses the total volume of cells after the simulation.
    :param: physicellPath
    :return: total cell volume
    """
    with open('logs.txt', 'a') as f:
        with redirect_stdout(f):
            subprocess.run(physicellPath / 'cultured_meat.exe', cwd=physicellPath, stdout=f)
            mcds = pyMCDS('final.xml', physicellPath / 'output')
            return sum(mcds.data['discrete_cells']['total_volume'])

def scatterPlotInputs(coordinates, saveTo):
    """
    Used to plot the initial cell placements because they are obscured in the PhysiCell output.
    Plots, saves, and displays a scatter-plot graph.
    :param coordinates: the coordinate pairs after decoding and pairing [(xxx,xxx),(xxx,xxx)]
    :param saveTo: the desired output folder
    """
    fig = plt.figure(1)
    fig.suptitle("Feeder Placement")
    xvals, yvals = list(zip(*coordinates))
    ax = fig.add_subplot(111)
    ax.set_aspect('equal', adjustable='box')
    plt.box(False)
    plt.xlim([-300,300])
    plt.ylim([-300,300])
    plt.xlabel('x, microns')
    plt.ylabel('y, microns')
    plt.scatter(xvals,yvals, label="Feeder Cells", c='limegreen')
    plt.savefig(saveTo / 'scatter.png')
    plt.show()

def linePlot(generations, yvals, title):
    """
    Used at the end of the simulation to visualize the progression of the algorithm.
    Plots, saves, and displays a line graph.
    :param generations: number of generations the simulation ran
    :param yvals: the evaluations at each of those generations
    :param title: the title to give the graph
    """
    fig, ax = plt.subplots(1, 1)
    fig.suptitle(title)
    xvals = [x for x in range(generations)]
    tickSpacing = 1
    ax.xaxis.set_major_locator(ticker.MultipleLocator(tickSpacing))
    plt.xlabel("generation")
    plt.ylabel("fitness = cellular volume in micron^3")
    plt.plot(xvals,yvals)
    fig.set_tight_layout(True)
    plt.savefig(Path.cwd() / 'output' / f"{title}.png")
    plt.show()



# decode bitstring to numbers
def decode(bounds, bitVarSize, bitstring):
    """
    Decodes a bitstring into numbers
    :param bounds: the bounds the decoded values will be scaled to
    :param bitVarSize: number of bits per numerical value
    :param bitstring: string of bits to decode
    :return: list containing numbers instead of binary
    """
    decoded = []
    largest = 2 ** bitVarSize
    for i in range(len(bounds)):
        lowerBound = bounds[i][0]
        upperBound = bounds[i][1]

        # start and end of each variable
        start = i * bitVarSize
        end = (i * bitVarSize) + bitVarSize
        # start, end = i * bitVarSize, (i * bitVarSize) + bitVarSize
        substring = bitstring[start:end]

        # chars = ''.join(str(s) for s in substring)
        # integer = int(chars, 2)

        # convert bits to ints using string operations
        integer = int(''.join(str(bit) for bit in substring), 2)

        # find divisors
        divisors = [x for x in range(1,int(largest / 2) + 1) if largest % x == 0]
        divisors.append(largest)

        # may not be correct... say we have something to the effect of [-1,256], would this still scale correctly?
        if all(abs(bound) in divisors for bound in [lowerBound,upperBound]):
            value = int(lowerBound + (integer/largest) * (upperBound - lowerBound))
        elif upperBound == largest and lowerBound in [-1 * largest, 0]:
            value = integer
        else:
            value = lowerBound + (integer/largest) * (upperBound - lowerBound)

        decoded.append(value)
    return decoded


def tournamentSelection(pop, scores, k=3):
    """
    Implements an optional tournament selection for larger tests. A random member of the population is chosen
    and compared against k random other members of the population and the scores compared. The member with the
    highest score is returned.
    :param pop: population of genes
    :param scores: the score for the particular gene
    :param k: number of genes to compare against
    :return: the best gene of those inspected
    """
    selectedIndex = randint(len(pop))
    for i in randint(0, len(pop), k-1):
        if scores[i] > scores[selectedIndex]:
            selectedIndex = i
    return pop[selectedIndex]


def bestSelection(pop, scores, overallBestInput, overallBestScore, numberOfParents=3):
    """
    Yields the top performers repeatedly. Not as efficient as tournament selection, but more useful for smaller
    populations and fewer generations.
    :param pop: population to evaluate
    :param scores: the scores associated with the population
    :param numberOfParents: the number of top performers to iterate through
    :return: one of the parents
    """
    paired = [*zip(pop,scores)]
    paired.sort(key=lambda x: x[1], reverse=True)

    # make sure to always seed the overall best performer, even if it comes from a previous generation
    if (paired[0][1]) < overallBestScore:
        paired.insert(0, (overallBestInput, overallBestScore))

    def gen_bestSelection(i):
        index = i
        while True:
            yield paired[index][0]
            index += 1
            if index >= numberOfParents:
                index = 0
    return gen_bestSelection(0)


def crossover(parent1, parent2, crossoverRate):
    """
    Takes two parent genes, decides if they will be crossed, then crosses them at a single point
    :param parent1: the first parent
    :param parent2: second parent
    :param crossoverRate: the likelihood that the genes will be crossed
    :return: the result of the single point crossover
    """
    # children start as copies of the parents
    child1, child2 = parent1.copy(), parent2.copy()

    if rand() < crossoverRate:
        # select crossover point that is not on the end
        crossoverPoint = randint(1, len(parent1) - 2)
        # swap bits starting at the crossover point
        child1 = parent1[:crossoverPoint] + parent2[crossoverPoint:]
        child2 = parent2[:crossoverPoint] + parent1[crossoverPoint:]
    return [child1, child2]


def mutation(bitstring, mutationRate):
    """
    Can possibly flip several bits in the string depending on the value of r_mut. Simulates random
    mutations in biological genes.
    :param bitstring: the population to iterate over
    :param mutationRate: the likelihood of mutation on any given gene. This should be fairly low
    :return: no return, modifies the bitstring fed to it
    """
    for i in range(len(bitstring)):
        if rand() < mutationRate:
            # bit-flip operation
            bitstring[i] = 1 - bitstring[i]


def geneticAlgorithm(objective,
                     bounds,
                     bitVarSize,
                     numberOfGenerations,
                     populationSize,
                     crossoverRate,
                     mutationRate,
                     physicellPath,
                     parentsSelected=3):
    """
    generate random bits within the size constraints of the extracted variables
    convert bits into floats/integers to input into the simulation
    plug them into the simulation
    run the simulation
    evaluate the volume of the cells produced during the simulation
    select parents
    apply crossover
    apply mutation
    repeat from "convert" for each generation I would like to produce
    :param objective: a function used to evaluate the fitness of a given gene
    :param bounds: bounds that the variables represented in bits will be scaled to
    :param bitVarSize: number of bits representing each variable in the bit string
    :param numberOfGenerations: number of generations to run through the genetic algorithm
    :param populationSize: size of each population
    :param crossoverRate: the likelihood of any pair of genes having a crossover, should be high
    :param mutationRate: the likelihood of any bit in the bit string to be randomly flipped, should be low
    :param physicellPath: the path to the physicell implementation
    :param parentsSelected: number of parents to select from each generation to seed the next generation
    :return: the index of the best performer, its fitness function evaluation, and the inputs that created it
    """

    settingPath = physicellPath / 'config' / 'PhysiCell_settings.xml'
    outputPath = physicellPath / 'output'

    # a generator used to keep track of the number of output csv and their names
    continuousOut = physicellOutputCapture(physicellPath / 'output', Path.cwd() / 'output' / 'progressive')

    # initial population of random bitstring
    pop = [randint(0, 2, bitVarSize * len(bounds)).tolist() for _ in range(populationSize)]
    print(f'initial random population: {pop[0]}', file=sys.stderr)

    best = 0
    bestInputs = None
    best_eval = - 1 * 2**64
    generationBestEvals = []
    bestFitnessSoFar = []

    growgenOutputPath = Path.cwd() / 'output'
    if not growgenOutputPath.exists():
        growgenOutputPath.mkdir(parents=True)

    for generation in range(numberOfGenerations):
        # a generation will run n_pop tests
        print(f"Starting generation {generation}")

        # create file structure for generation
        generationDirName = f"generation{str(generation).zfill(8)}"
        generationPath = growgenOutputPath / generationDirName
        if not generationPath.exists():
            generationPath.mkdir(parents=True)

        generationBest = 0
        generationBestScore = 0
        generationBestInputs = 0
        startTime = time()
        pop_decoded = [decode(bounds, bitVarSize, p) for p in pop]

        # Run PhysiCell to evaluate all of the random pairs, updating best and best eval as we go
        generationScores = []
        for index,arrangement in enumerate(pop_decoded):
            # create file structure to save gene
            geneDirName = f"gene{str(index).zfill(8)}"
            genePath = generationPath / geneDirName
            if not genePath.exists():
                genePath.mkdir(parents=True)

            integerInputs = pop_decoded[index]
            # print(f"coordinates: {integerInputs}")
            coordinates = [tuple(integerInputs[i:i + 2]) for i in range(0, len(integerInputs), 2)]

            # generate a csv file from the decoded population
            with open(physicellPath / 'coords.csv', 'w') as f:
                [print(str(integerInputs[i:i + 2]).strip("[]") + ", 0, 3",file=f) for i in range(0,len(integerInputs),2)]

            # copy coords.csv to gene output
            copyfile(physicellPath / 'coords.csv', genePath / 'coords.csv')

            # Create a scatter-plot of the input coordinates, display it, and save it to gene output
            scatterPlotInputs(coordinates, genePath)

            # run fitness function for current arrangement of feeder cells
            current_eval = objective(physicellPath)
            generationScores.append(current_eval)

            print(f"    {index}: evaluation = {current_eval:.4f}, coordinates: {coordinates}")

            # save the evaluation into gene output
            with open(genePath / 'evaluation.txt', 'w') as evaluation:
                print(f"{current_eval}",file=evaluation)

            # save the svgs that PhysiCell creates into gene output
            copyfile(physicellPath / 'output' / 'initial.svg', genePath / 'initial.svg')
            copyfile(physicellPath / 'output' / 'final.svg', genePath / 'final.svg')

            # Evaluates the bests for the current generation
            if current_eval > generationBestScore:
                generationBest = index
                generationBestInputs = arrangement
                generationBestScore = current_eval

            # keep track of the best performers overall
            if current_eval > best_eval:
                best = index
                bestInputs = arrangement
                bestInputsRaw = pop[index]
                best_eval = current_eval
                best_generation = generation
                # this call causes the best performer to be saved in the genetic algorithm output folders
                progFileNumber = next(continuousOut)
                scatterTarget = growgenOutputPath / 'progressive' / 'bestInitials' / f'scatter{progFileNumber}.png'
                copyfile(genePath / 'scatter.png', scatterTarget)

        endTime = time()
        print(f"Generation {generation} computed in {endTime - startTime:.4f} seconds,"
              f" generation best = {generationBestScore}, {generationBest}: {generationBestInputs}")
        print(f"Overall best = {best_eval}, from generation {best_generation}, index {best}: {bestInputs}")

        # Track the best evaluation at the end of each generation
        generationBestEvals.append(generationBestScore)
        # Track the best fitness yet seen at the end of each generation
        bestFitnessSoFar.append(best_eval)

        # The following code blocks sort files into their summary folders
        currentGenBestGenePath = growgenOutputPath / f"generation{str(generation).zfill(8)}" / f"gene{str(generationBest).zfill(8)}"

        generationBestsPath = growgenOutputPath / 'generationbests'
        if not generationBestsPath.exists():
            generationBestsPath.mkdir(parents=True)

        initials = generationBestsPath / 'bestInitials'
        finals = generationBestsPath / 'bestFinals'
        if not initials.exists():
            initials.mkdir(parents=True)
        if not finals.exists():
            finals.mkdir(parents=True)

        fileNumber = str(generation).zfill(8)
        copyfile(currentGenBestGenePath / 'initial.svg', initials / f"initial{fileNumber}.svg")
        copyfile(currentGenBestGenePath / 'scatter.png', initials / f"scatter{fileNumber}.png")
        copyfile(currentGenBestGenePath / 'final.svg', finals / f"final{fileNumber}.svg")


    # Select parents from the current generation to seed the next generation
        bestParents = bestSelection(pop, generationScores, bestInputsRaw, best_eval, parentsSelected)
        selected = [next(bestParents) for _ in range(populationSize)]

        # use this for the tournament selection instead:
        # selected = [tournamentSelection(pop, generationScores, num_parents) for _ in range(n_pop)]

        print(f"Selected parents: {selected}")
        children = []
        for i in range(0, populationSize, 2):

            if i + 1 < len(selected):
                parent1, parent2 = selected[i], selected[i+1]
            else:
                parent1, parent2 = selected[i], selected[0]

            for c in crossover(parent1, parent2, crossoverRate):
                mutation(c, mutationRate)
                children.append(c)

        # the next generation will be this generation's children
        pop = children
        print(f"        children: {children}")

    stats = {
        "index"     : best,
        "score"     : best_eval,
        "inputs"    : bestInputs,
        "generation": best_generation,
        "soFar"     : bestFitnessSoFar,
        "perGen"    : generationBestEvals
    }

    return stats


########################################################################################################################
##                                     GENETIC ALGORITHM INPUT PARAMETERS                                             ##
########################################################################################################################

# Path to PhysiCell implementation. Note: requires V.1.8.0 or greater in order to use csv to place cells
physicellPath = Path('C:/Users/korle/Documents/0USU/Spring 2021/CS5890 AI and Clean Energy/PhysiCell_V.1.8.0/PhysiCell/')

# The following code can be used when the genetic algorithm is intended to modify xml settings for PhysiCell:
# settingPath = physicellPath / 'config' / 'PhysiCell_settings.xml'
# outputPath = physicellPath / 'output'
# get settings
# settings = readSettings(settingPath)
#
# Settings for modifying oxygen starting parameters
# settings['oxygen']['initial_condition'] = 38.0
# saveXMLsettings(settingPath, settings)


# number of feeder cells to place
# each feeder will have an x and y coordinate, so the input will contain twice as many ints as feeders
feeders = 150

# the location bounds for each feeder
# may be set manually, or set as a group using this loop
bounds = []
for feeder in range(feeders * 2):
    bounds += [[-256, 256]]

# define the total number of generations to simulate
# each generation will run a PhysiCell simulation for each member of its population
generations = 10

# bits per variable
# each variable is represented as a string of bits internally. The variable will be scaled to the bound sizes, but
# this represents how many bits, and thus the acuity, the algorithm will use for each variable
bitVarSize = 9

# population size
# each generation contains a population of different input parameters. The number of different inputs to test in
# each generation is the popsize. PhysiCell will evaluate the fitness of each member of the population with its own
# simulation
populationSize = 10

# crossover rate
# how likely the parents are to mix their genes to form offspring. Too low of a value will result in most children
# being direct copies of their parents
crossoverRate = 0.9

# mutation rate
# how likely each bit in a variable is to be flipped when forming the next generation. Too high of a value will result
# in too much chaos and the algorithm will not be able to converge on an ideal solution.
# Too low of a value will result in no new genes being introduced
mutationRate = 1.0 / (float(bitVarSize) * len(bounds))

# the number of parents to select from each generation to seed the next. Note that one parent for the next generation
# will always be the best performing gene, whether or not it came from the generation just evaluated
parentsSelected = 3

########################################################################################################################
########################################################################################################################

# Track simulation time
startTime = time()

# run the genetic algorithm
stats = geneticAlgorithm(
    fitnessEvaluation,
    bounds,
    bitVarSize,
    generations,
    populationSize,
    crossoverRate,
    mutationRate,
    physicellPath,
    parentsSelected)

# animate the progress made with each solution that performs better than the last
# first parameter here is the file the outputs are found in, and should not be changed. The next two correspond to the
# width and height of the animation, the third is the filetype in the directory to animate, the fourth parameter is the
# filetype 'gif' or 'webp' that the animation will be saved in, and the last is the framerate
# in milliseconds. This call can be commented out if no animation is desired.
animate(Path.cwd() / 'output' / 'progressive', 800, 600,'svg', 'gif', 2000)
animate(Path.cwd() / 'output' / 'progressive', 800, 600,'png', 'gif', 2000)
animate(Path.cwd() / 'output' / 'generationbests', 800, 600, 'svg', 'gif', 2000)
animate(Path.cwd() / 'output' / 'generationbests', 800, 600, 'png', 'gif', 2000)

# Graph the best outputs
linePlot(generations, stats["soFar"], "Best Fitness So Far")
linePlot(generations, stats["perGen"], "Best Fitness of Generation")

endTime = time()
print(f'Done in {strftime("%H hours, %M minutes, %S seconds",gmtime(endTime - startTime))}.')
print(f'best score: {stats["score"]}, at generation: {stats["generation"]} index: {stats["index"]} inputs: {stats["inputs"]}')
